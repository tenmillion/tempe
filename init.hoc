//-------- Revamped Bush et al. 1999 Model --------
// Implemented by Y Yamamura, 6 October 2013       
// Reads weights from external files, generated by
// connectionmatrix.py
// For now altering internal weights by scaling
//-------------------------------------------------

load_file("pyramidal.hoc")
load_file("basket.hoc")
load_file("stdrun.hoc")

//-----------Basic settings-----------
celsius = 37	// degC
inp = 0.015		// uS
inb = 0.010		// uS
//record = 20	// cell ID
p2pscale = 2.0	// *1nS
p2bscale = 0.25	// *1nS
b2pscale = 1.0	// *4nS
nmdamu = 0.5	// nS

npyr = 400
nbas = 100
nbasb = 16 // Number of basket cells that make GABAB instead of GABAA synapses

scale = 0.001	// scale for internal weights. Just to use less zeros in file.
gababscale = 0.05 // To use the same source file. Converts mean 4 to 0.2 nS


if (name_declared("degc")==5) {
   celsius = degc
}
if (name_declared("ip")==5) {
   inp = ip
}
if (name_declared("ib")==5) {
   inb = ib
}
if (name_declared("pp")==5) {
   p2pscale = pp
}
if (name_declared("pb")==5) {
   p2bscale = pb
}
if (name_declared("bp")==5) {
   b2pscale = bp
}
if (name_declared("nmda")==5) {
   nmdamu = nmda
}
//if (name_declared("rec")==5) {
//   record = rec
//}

//-----------Create cells-----------
objectvar pyr[npyr]
for i = 0, npyr-1 {
    pyr[i] = new Pyramidal()	// in pyramidal.hoc
}

objectvar bas[nbas]
for i = 0, nbas-1 {
    bas[i] = new Basket()		// in basket.hoc
}

//-----------Make intrinsic connections-----------
objref p2pfile, p2bfile, b2pfile
objref p2pdlfile, p2bdlfile, b2pdlfile  // Reading delays from file as well.
p2pfile = new File()
p2bfile = new File()
p2pdlfile = new File()
p2bdlfile = new File()
b2pfile = new File()
b2pdlfile = new File()
printf("Connections:")
nump2pa = 0
nump2pn = 0
nump2b = 0
numb2pa = 0
numb2pb = 0

objref rwt, rdl
rwt = new Random()
rwt.normal(nmdamu, nmdamu/2)
rdl = new Random()
rdl.normal(1.2, 0.6)

p2pfile.ropen("p2p.dat")
p2bfile.ropen("p2b.dat")
p2pdlfile.ropen("p2pdl.dat") // This is actually a big waste of file i/o, but till I can think of something better
p2bdlfile.ropen("p2bdl.dat")

ndl = 0 // NMDA delays
nwt = 0 // NMDA weights

for i = 0, npyr-1 {
    for j = 0, npyr-1 { // Set pyramidal -> pyramidal weights
        wt = p2pfile.scanvar()
		dl = p2pdlfile.scanvar()
        if (wt != 0) {
			ndl = rdl.repick()
			nwt = rwt.repick()
			if (ndl < 0.5) { // Why doesn't hoc have max(a,b)?????
				ndl = 0.5
			}
			if (nwt <= 0) {
				nwt = 0
				nump2pn = nump2pn-1 // Don't count if weight is 0
			}
            pyr[i].soma pyr[j].nclist.append(new NetCon(&v(0.5), pyr[j].ampa[0],-20, dl, wt*scale*p2pscale))
			pyr[i].soma pyr[j].nclist.append(new NetCon(&v(0.5), pyr[j].nmda[0],-20, ndl, nwt*scale*p2pscale))
			nump2pa = nump2pa+1
			nump2pn = nump2pn+1
		}
    }
    for j = 0, nbas-1 { // Set pyramidal -> basket weights
        wt = p2bfile.scanvar()
		dl = p2bdlfile.scanvar()
        if (wt != 0) {
            pyr[i].soma bas[j].nclist.append(new NetCon(&v(0.5), bas[j].ampa[0],-20, dl, wt*scale*p2bscale))
			nump2b = nump2b+1
        }
    }
}
p2pfile.close()
p2bfile.close()

b2pfile.ropen("b2p.dat")
b2pdlfile.ropen("b2pdl.dat")

for i = 0, (nbas-nbasb)-1 { // GABAA connections
    for j = 0, npyr-1 { // Set basket -> pyramidal weights
        wt = b2pfile.scanvar()
        dl = b2pdlfile.scanvar()
        if (wt != 0) {
            bas[i].soma pyr[j].nclist.append(new NetCon(&v(0.5), pyr[j].gabaa[0],-20, dl, wt*scale*b2pscale))
			numb2pa = numb2pa+1
        }
    }
}
// Todo: read from separate file (necessary to provide separate files? why not just scale?)
for i = 0, nbasb-1 { // GABAB connections
    for j = 0, npyr-1 { // Set basket -> pyramidal weights
        wt = b2pfile.scanvar()
        dl = b2pdlfile.scanvar()
        if (wt != 0) {
            bas[i].soma pyr[j].nclist.append(new NetCon(&v(0.5), pyr[j].gabab[0],-20, dl, wt*scale*gababscale))
			numb2pb = numb2pb+1
        }
    }
}
b2pfile.close()

printf("p2pa:")
print nump2pa
printf("p2pn:")
print nump2pn
printf("p2b:")
print nump2b
printf("b2pa:")
print numb2pa
printf("b2pb:")
print numb2pb

//-----------Make extrinsic input-----------
objref spgen, nc, nc_list
nc_list = new List()
printf("Extrinsic input:")

spgen = new NetStim() // generates spike train, synapse defined on receiving end 
spgen.interval = 0    // ms
spgen.number = 1      // times
spgen.start = 50      // ms
spgen.noise = 0	      // deterministic

spyr = npyr/20		// # pyramidal cells stimulated /2
sbas = nbas/20		// # basket cells stimulated /2

for i = 0, 2*spyr-1 {  // stimulate 1 sigma
    nc = new NetCon(spgen, pyr[i].ext[0])
    nc.delay = 0
    nc.weight = inp*exp(-0.5*((i-spyr)/spyr)^2)
    nc_list.append(nc)
    print nc.weight
}
printf("# pyr stimulated, inp")
print 2*spyr
print inp

for i = 0, 2*sbas-1 {  // stimulate 1 sigma
    nc = new NetCon(spgen, bas[i].ext[0])
    nc.delay = 0
    nc.weight = inb*exp(-0.5*((i-sbas)/sbas)^2)
    nc_list.append(nc)
    print nc.weight
}
printf("# bas stimulated, inb")
print 2*sbas
print inb

//-----------Initialize-----------
tstop = 1000	// from stdrun.hoc
// No voltage init?

//-----------Record spikes-----------
objref recs, recid, sp_list, sp, nil
recs = new Vector()
recid = new Vector()
sp_list = new List()
for i=0,npyr-1 {
  pyr[i].soma sp = new NetCon(&v(0.5), nil)
  sp.threshold = -20
  sp.record(recs, recid, i+1) // so all the spike rasters lie above the x axis
  sp_list.append(sp)
}
for i=0,nbas-1 {
  bas[i].soma sp = new NetCon(&v(0.5), nil)
  sp.threshold = -20
  sp.record(recs, recid, npyr+i+1) 
  sp_list.append(sp)
}
objref sp // so we don't accidentally mess up the last NetCon
printf("Number of cells:")
print sp_list.count()
printf("Size of recs:")
print recs.size()

//-----------Record voltage------------
//objref recv, rect

//recv = new Vector()
//recv.record(&pyr[record-1].soma.v(0.5))
//rect = new Vector()
//rect.record(&t)

//recv = new Vector()
//recv.record(&bas[record-1].soma.v(0.5))
//rect = new Vector()
//rect.record(&t)

//printf("length of voltage trace:")
//print recv.size()

//-----------Run-----------
printf("Running simulation...")
print celsius
print inp
print inb
print p2pscale
print p2bscale
print b2pscale
run()

//Outputs an empty file when there were no spikes
strdef ef
objref empty
empty = new File()
sprint(ef, "s-degc%3.1f-inp%3.3f-inb%3.3f-pp%3.5f-pb%3.5f-bp%3.5f-nmda%3.5f.dat", celsius, inp, inb, p2pscale, p2bscale, b2pscale, nmdamu)
empty.wopen(ef)
empty.printf("No spikes.\n 0 0\n")
empty.close()
//Later overwritten by populated file if there were spikes

if (recs.size() <= 0) { // If there were no spikes
   printf("No spikes.\n")
   quit()
}
printf("recid size:")
print recid.size() 
printf("recs size:")
print recs.size()
//printf("recv len:")
//print recv.size()

//-----------Graph & Write to file-----------
//printf("graph")
//objectvar g
//g = new Graph()
//g.size(0,1000,0,500)
//recid.mark(g, recs, "O", 1)
//g.flush()	 // Show the graph

strdef fname
objref outfile
outfile = new File()
sprint(fname, "s-degc%3.1f-inp%3.3f-inb%3.3f-pp%3.5f-pb%3.5f-bp%3.5f-nmda%3.5f.dat", celsius, inp, inb, p2pscale, p2bscale, b2pscale, nmdamu)
outfile.wopen(fname)
objref tempmatrix
tempmatrix = new Matrix()
tempmatrix.resize(recs.size(),2)
tempmatrix.setcol(0, recs)
tempmatrix.setcol(1, recid)
tempmatrix.fprint(outfile, " %g")
outfile.close()

//strdef fname2
//objref outfile2
//outfile2 = new File()
//sprint(fname2, "v-%3d-degc%3.1f-input%3.2f.dat", record, celsius, input)
//outfile2.wopen(fname2)
//objref tempmatrix2
//tempmatrix2 = new Matrix()
//tempmatrix2.resize(recv.size(),2)
//tempmatrix2.setcol(0, rect)
//tempmatrix2.setcol(1, recv)
//tempmatrix2.fprint(outfile2, " %g")
//outfile2.close()

quit()